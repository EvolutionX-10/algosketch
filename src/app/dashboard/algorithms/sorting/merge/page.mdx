import Visualizer from "@/components/merge/visualizer";

# Merge Sort Algorithm

Merge Sort is an efficient, stable sorting algorithm that uses a divide-and-conquer approach to order elements in an array. It was invented by John von Neumann in 1945 and has remained one of the most popular sorting algorithms due to its consistent performance.

## How Merge Sort Works

Merge Sort follows the divide-and-conquer paradigm with three key steps:

1. **Divide**: Recursively split the array into two halves until each subarray contains a single element
2. **Conquer**: Single-element arrays are inherently sorted
3. **Combine**: Merge the sorted subarrays back together to form larger sorted arrays

This process continues until all pieces are merged back into one fully sorted array.

### Algorithm Steps

1. If the array has only one element or is empty, it is already sorted
2. Divide the array into two subarrays of approximately equal size
3. Recursively sort the two subarrays
4. Merge the sorted subarrays to form a single sorted array

## Visual Representation

Consider this unsorted array: `[38, 27, 43, 3, 9, 82, 10]`

**Dividing Phase:**

```
         [38, 27, 43, 3, 9, 82, 10]
                /           \
    [38, 27, 43, 3]       [9, 82, 10]
        /     \             /     \
  [38, 27]   [43, 3]     [9]    [82, 10]
    /  \      /  \              /    \
 [38] [27]  [43] [3]         [82]   [10]
```

**Merging Phase:**

```
 [38] [27]  [43] [3]         [82]   [10]
    \  /      \  /              \    /
  [27, 38]   [3, 43]           [10, 82]
       \       /                   /
   [3, 27, 38, 43]           [9, 10, 82]
             \                    /
         [3, 9, 10, 27, 38, 43, 82]
```

## Time Complexity

- **Worst-case time complexity**: O(n log n)
- **Average-case time complexity**: O(n log n)
- **Best-case time complexity**: O(n log n)
- **Stability**: Stable - equal elements maintain their relative order

## Space Complexity

Merge sort has a space complexity of O(n) because it requires additional memory proportional to the size of the input array for the merging process.

## Implementation in JavaScript

```js
function mergeSort(arr) {
  // Base case: single item arrays are already sorted
  if (arr.length <= 1) return arr;
  
  // Divide: Split the array into halves
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  // Combine: Merge the sorted halves
  return merge(left, right);
}

function merge(left, right) {
  const merged = [];
  let i = 0;
  let j = 0;
  
  // Compare elements from both arrays and merge in sorted order
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      merged.push(left[i]);
      i++;
    } else {
      merged.push(right[j]);
      j++;
    }
  }
  
  // Add any remaining elements
  merged.push(...left.slice(i));
  merged.push(...right.slice(j));
  
  return merged;
}

// Example usage
const array = [38, 27, 43, 3, 9, 82, 10];
console.log(mergeSort(array)); // [3, 9, 10, 27, 38, 43, 82]
```

## Advantages and Disadvantages

### Advantages

- Guaranteed O(n log n) performance regardless of input data
- Stable sort - maintains relative order of equal elements
- Works well on linked lists with O(1) extra space
- Efficient for large datasets
- Parallelization potential for distributed computing

### Disadvantages

- Requires O(n) extra space for merging operations
- Not an in-place sorting algorithm in most implementations
- Recursive calls can lead to stack overflow for extremely large arrays
- May be slower than other algorithms for small arrays due to overhead

## When to Use Merge Sort

Merge sort is ideal for:

- Applications where stable sorting is required
- External sorting where data doesn't fit in memory
- Large datasets where consistent O(n log n) performance is critical
- Linked list sorting (can be implemented with O(1) extra space)
- Parallel processing environments

## Optimizations

### Insertion Sort for Small Subarrays

For small subarrays (typically less than 10-20 elements), switching to insertion sort can improve performance:

```js
function mergeSortOptimized(arr) {
  if (arr.length <= 10) {
    return insertionSort(arr);
  }
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSortOptimized(arr.slice(0, mid));
  const right = mergeSortOptimized(arr.slice(mid));
  
  return merge(left, right);
}
```

### In-place Merge

To reduce space complexity, various in-place merge sort implementations exist, though they typically increase time complexity to O(n logÂ² n).

## Real-world Applications

- Database sorting operations
- External sorting in file systems
- Sorting in Unix systems
- Implementations in programming language standard libraries
- Part of hybrid sorting algorithms like TimSort (used in Python, Java)

<Visualizer />