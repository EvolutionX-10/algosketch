import Visualizer from "@/components/quick/visualizer";
import PartitionTreeVisualization from "@/components/quick/partition-tree-visualization";
import CodeSnippet from "@/components/quick/codeBlock";

# Quick Sort Algorithm

Quick Sort is a highly efficient divide-and-conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot.

## How Quick Sort Works

Quick Sort follows the divide-and-conquer paradigm and consists of three main steps:

### Algorithm Steps

1. **Choose a pivot**: Select an element from the array as the pivot (commonly the last element)
2. **Partition**: Rearrange the array so that all elements smaller than the pivot come before it, and all elements greater come after it
3. **Recursively apply**: Apply the same process to the sub-arrays on either side of the pivot

### Partitioning Process

The partitioning process is the heart of Quick Sort:

1. Choose the rightmost element as the pivot
2. Keep track of the index of the smaller element
3. Traverse through the array from left to right
4. If an element is smaller than or equal to the pivot, swap it with the element at the smaller index
5. Finally, swap the pivot with the element right after the last smaller element

## Visual Representation

Consider this unsorted array: `[8, 3, 5, 4, 7, 6, 1, 2]`

### Partitioning Tree Structure

<PartitionTreeVisualization
	data={[8, 3, 5, 4, 7, 6, 1, 2]}
	title="Quick Sort Partitioning Tree"
	subtitle="Shows how the array is recursively partitioned around pivot elements"
	pivotStrategy="last"
/>

The tree above shows how Quick Sort recursively partitions the array:

- Each node represents a partition operation
- Blue connections show left partitions (≤ pivot)
- Red connections show right partitions (> pivot)
- Green nodes are base cases (≤1 element)

### Step-by-Step Process

**First Partition (Pivot = 2):**

- Elements ≤ 2: `[1, 2]` (left partition)
- Elements > 2: `[8, 3, 5, 4, 7, 6]` (right partition)

**Recursive Partitioning:**
The process continues on each partition until all sub-arrays have ≤1 element.

## Time Complexity

- **Best-case time complexity**: O(n log n) - when the pivot always divides the array into two equal halves
- **Average-case time complexity**: O(n log n) - with random pivot selection
- **Worst-case time complexity**: O(n²) - when the pivot is always the smallest or largest element
- **Stability**: Unstable - equal elements may not maintain their relative order

## Space Complexity

Quick Sort has a space complexity of O(log n) on average due to the recursive call stack. In the worst case, it can be O(n) if the recursion depth becomes n.

## Implementation
<CodeSnippet />

## Advantages and Disadvantages

### Advantages

- Very efficient for large datasets
- In-place sorting (requires only O(log n) extra space)
- Cache-efficient due to good locality of reference
- Widely used in practice

### Disadvantages

- Worst-case time complexity is O(n²)
- Not stable (doesn't preserve relative order of equal elements)
- Performance depends heavily on pivot selection

## When to Use Quick Sort

Quick Sort is ideal for:

- Large datasets where average-case performance matters
- Systems where memory usage is a concern (in-place sorting)
- General-purpose sorting when stability is not required
- Applications where cache performance is important

## Optimizations

### Pivot Selection Strategies

**Random Pivot**: Choose a random element as pivot to avoid worst-case scenarios:

```js
function randomizedPartition(arr, low, high) {
	// Choose random pivot and swap with last element
	const randomIndex = Math.floor(Math.random() * (high - low + 1)) + low;
	[arr[randomIndex], arr[high]] = [arr[high], arr[randomIndex]];
	return partition(arr, low, high);
}
```

**Median-of-Three**: Choose the median of first, middle, and last elements:

```js
function medianOfThree(arr, low, high) {
	const mid = Math.floor((low + high) / 2);
	if (arr[mid] < arr[low]) [arr[low], arr[mid]] = [arr[mid], arr[low]];
	if (arr[high] < arr[low]) [arr[low], arr[high]] = [arr[high], arr[low]];
	if (arr[high] < arr[mid]) [arr[mid], arr[high]] = [arr[high], arr[mid]];
	[arr[mid], arr[high]] = [arr[high], arr[mid]];
}
```

### Hybrid Approach

For small subarrays, switch to insertion sort for better performance:

```js
function hybridQuickSort(arr, low = 0, high = arr.length - 1) {
	if (high - low < 10) {
		insertionSort(arr, low, high);
	} else if (low < high) {
		const pivotIndex = partition(arr, low, high);
		hybridQuickSort(arr, low, pivotIndex - 1);
		hybridQuickSort(arr, pivotIndex + 1, high);
	}
}
```

## Real-world Applications

- Standard library implementations (C++ std::sort, Java Arrays.sort)
- Database query optimization
- Numerical computations
- Data processing pipelines
- Operating system utilities

## Comparison with Other Algorithms

Unlike Merge Sort, Quick Sort is an in-place algorithm but is not stable. Unlike Heap Sort, Quick Sort has better average-case performance and cache locality, making it preferred for general-purpose sorting.

<Visualizer />
