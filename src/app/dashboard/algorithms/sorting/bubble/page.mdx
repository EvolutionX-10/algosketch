import Visualizer from "@/components/bubble/visualizer";

# Bubble Sort Algorithm

Bubble Sort is one of the simplest sorting algorithms that works by repeatedly stepping through the list, comparing each pair of adjacent elements, and swapping them if they are in the wrong order.

## How Bubble Sort Works

Bubble sort gets its name because smaller elements "bubble" to the top of the list (or larger elements sink to the bottom) with each iteration through the array.

### Algorithm Steps

1. Start at the beginning of the array
2. Compare the current element with the next element
3. If the current element is greater than the next element, swap them
4. Move to the next element and repeat step 2
5. After completing one full pass, the largest element will be at the end
6. Repeat steps 1-5 for all elements except the last one (which is already sorted)
7. Continue until no more swaps are needed

## Visual Representation

Consider this unsorted array: `[5, 3, 8, 4, 2]`

**First Pass:**

- Compare 5 and 3: Swap → `[3, 5, 8, 4, 2]`
- Compare 5 and 8: No swap → `[3, 5, 8, 4, 2]`
- Compare 8 and 4: Swap → `[3, 5, 4, 8, 2]`
- Compare 8 and 2: Swap → `[3, 5, 4, 2, 8]`

**Second Pass:**

- Compare 3 and 5: No swap → `[3, 5, 4, 2, 8]`
- Compare 5 and 4: Swap → `[3, 4, 5, 2, 8]`
- Compare 5 and 2: Swap → `[3, 4, 2, 5, 8]`

**Third Pass:**

- Compare 3 and 4: No swap → `[3, 4, 2, 5, 8]`
- Compare 4 and 2: Swap → `[3, 2, 4, 5, 8]`

**Fourth Pass:**

- Compare 3 and 2: Swap → `[2, 3, 4, 5, 8]`

Final sorted array: `[2, 3, 4, 5, 8]`

## Time Complexity

- **Worst-case time complexity**: O(n²) - when the array is sorted in reverse order
- **Average-case time complexity**: O(n²)
- **Best-case time complexity**: O(n) - when the array is already sorted (with optimizations)
- **Stability**: Stable - equal elements maintain their relative order

## Space Complexity

Bubble sort has a space complexity of O(1) because it only requires a single additional memory space for the swapping temp variable.

## Implementation in JavaScript

```js
function bubbleSort(arr) {
	const n = arr.length;
	let swapped;

	for (let i = 0; i < n; i++) {
		swapped = false;

		// Last i elements are already in place
		for (let j = 0; j < n - i - 1; j++) {
			// Compare adjacent elements
			if (arr[j] > arr[j + 1]) {
				// Swap them if they are in wrong order
				[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
				swapped = true;
			}
		}

		// If no swapping occurred in this pass, array is sorted
		if (!swapped) break;
	}

	return arr;
}

// Example usage
const array = [5, 3, 8, 4, 2];
console.log(bubbleSort(array)); // [2, 3, 4, 5, 8]
```

## Advantages and Disadvantages

### Advantages

- Simple to understand and implement
- Requires no additional memory space
- Works well with small datasets

### Disadvantages

- Inefficient for large datasets
- O(n²) time complexity makes it impractical for production use
- Performs poorly compared to more advanced algorithms like Quick Sort, Merge Sort, or Heap Sort

## When to Use Bubble Sort

Bubble sort is primarily used for:

- Educational purposes to introduce sorting algorithms
- Very small datasets where simplicity is more important than efficiency
- Cases where a stable sort is needed and code simplicity is a priority

## Optimizations

### Early Termination

The algorithm can be optimized by stopping if the inner loop didn't cause any swap, indicating the array is already sorted:

```js
function optimizedBubbleSort(arr) {
	let n = arr.length;
	let swapped;

	do {
		swapped = false;

		for (let i = 0; i < n - 1; i++) {
			if (arr[i] > arr[i + 1]) {
				[arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
				swapped = true;
			}
		}

		// Decrease n because the last element is in place
		n--;
	} while (swapped);

	return arr;
}
```

<Visualizer />
