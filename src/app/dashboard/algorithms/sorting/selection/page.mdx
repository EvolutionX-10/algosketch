import Visualizer from "@/components/selection/visualizer";

# Selection Sort Algorithm

Selection Sort is a simple and intuitive sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list.

## How Selection Sort Works

Selection Sort divides the input list into two parts: a sorted sublist that is built up from left to right, and an unsorted sublist that occupies the rest of the list.

### Algorithm Steps

1. Find the smallest element in the unsorted sublist
2. Swap it with the leftmost element of the unsorted sublist
3. Move the boundary between the sorted and unsorted sublists one element to the right
4. Repeat steps 1-3 until the entire list is sorted

## Visual Representation

Consider this unsorted array: `[5, 3, 8, 4, 2]`

**First Pass:**

- Find the minimum element in positions 0-4: value 2 at index 4
- Swap with element at position 0: `[2, 3, 8, 4, 5]`

**Second Pass:**

- Find the minimum element in positions 1-4: value 3 at index 1
- Element is already at position 1, no swap needed: `[2, 3, 8, 4, 5]`

**Third Pass:**

- Find the minimum element in positions 2-4: value 4 at index 3
- Swap with element at position 2: `[2, 3, 4, 8, 5]`

**Fourth Pass:**

- Find the minimum element in positions 3-4: value 5 at index 4
- Swap with element at position 3: `[2, 3, 4, 5, 8]`

Final sorted array: `[2, 3, 4, 5, 8]`

## Time Complexity

- **Worst-case time complexity**: O(n²)
- **Average-case time complexity**: O(n²)
- **Best-case time complexity**: O(n²) - unlike insertion or bubble sort, selection sort always examines all elements
- **Stability**: Unstable - equal elements might change order

## Space Complexity

Selection sort has a space complexity of O(1) because it sorts in-place, requiring only a constant amount of additional memory for the temporary variable used in swapping.

## Implementation in JavaScript

```js
function selectionSort(arr) {
	const n = arr.length;

	for (let i = 0; i < n - 1; i++) {
		// Find the minimum element in unsorted part
		let minIndex = i;

		for (let j = i + 1; j < n; j++) {
			// Compare with current minimum
			if (arr[j] < arr[minIndex]) {
				// Update minimum index if found
				minIndex = j;
			}
		}

		// Swap the found minimum with the first unsorted element
		if (minIndex !== i) {
			[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
		}
	}

	return arr;
}

// Example usage
const array = [5, 3, 8, 4, 2];
console.log(selectionSort(array)); // [2, 3, 4, 5, 8]
```

## Advantages and Disadvantages

### Advantages

- Simple implementation with minimal code
- Performs well on small arrays
- Makes the minimum possible number of swaps (n-1 in the worst case)
- Works well when memory write is a costly operation

### Disadvantages

- Inefficient for large datasets
- Always performs O(n²) comparisons even if the array is already sorted
- Unstable sorting algorithm (relative order of equal elements might change)
- Generally performs worse than insertion sort

## When to Use Selection Sort

Selection sort is primarily used for:

- Small arrays where simplicity is more important than efficiency
- Situations where the cost of swapping elements is high compared to the cost of comparisons
- Educational purposes to introduce sorting concepts
- When memory usage is a concern

## Comparison with Other Algorithms

Unlike Bubble Sort, which makes many exchanges, Selection Sort minimizes the number of actual swaps needed. It performs exactly n-1 swaps, which can be beneficial when the write operation is costly.

Unlike Insertion Sort, which works well for nearly sorted arrays, Selection Sort always takes quadratic time regardless of the initial order of elements.

<Visualizer />
